---
output: github_document
---

<!-- README.md is generated from README.Rmd. Please edit that file -->

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.path = "man/figures/README-",
  out.width = "100%"
)
```

# parentframecpp

<!-- badges: start -->
<!-- badges: end -->

This package demonstrates a quirk with `parent.frame()` in R when the call stack routes through C++.

When you have a function signature like `foo <- function(..., envir = parent.frame())` and call it through a C++ intermediate (R → C++ → R), `parent.frame()` resolves to `globalenv()` instead of the expected parent frame. This happens because invoking an R function from C++ doesn't create an R evaluation frame.

This messes up things like `withr::defer()` cleanup and error messaging.

## Installation

You can install the development version of parentframecpp like so:

``` r
pak::pak("jennybc/parentframecpp")
```

## The demo

```{r}
library(parentframecpp)
```

The key player is `report_parent()`, an unexported helper function, which captures its `parent.frame()` as a default argument.

```{r}
parentframecpp:::report_parent
```

We call `report_parent()` from two wrapper functions that each create a local sentinel variable, then call `report_parent()`.
The difference is *how* they call it.

```{r}
via_r

via_cpp
```

The C++ intermediate (`call_report_from_cpp`) simply looks up and invokes `report_parent()`:

```cpp
[[cpp11::register]]
void call_report_from_cpp() {
  cpp11::function report_parent = cpp11::package("parentframecpp")["report_parent"];
  report_parent();
}
```

Now the demo:

```{r example}
# morally, we want:
# I_am_globalenv <- TRUE
# but because of knitr stuff, this is more reliable in the context of README.Rmd
assign("I_am_globalenv", TRUE, envir = globalenv())

via_r()

via_cpp()
```

When called via pure R, `parent.frame()` correctly resolves to `via_r()`'s environment (we see `I_am_via_r`).
When routed through C++, `parent.frame()` resolves to `globalenv()` instead of `via_cpp()`'s environment.

## The `withr::defer()` example

Let's explore via another angle: scheduling cleanup with `withr::defer()`.

The helper creates a temp file and schedules its deletion in its `parent.frame()`:

```{r}
parentframecpp:::helper_with_cleanup
```

Again, two wrappers that differ only in *how* they call the helper:

```{r}
via_r_cleanup

via_cpp_cleanup
```

The C++ intermediate:

```cpp
[[cpp11::register]]
cpp11::sexp call_cleanup_from_cpp() {
  cpp11::function helper = cpp11::package("parentframecpp")["helper_with_cleanup"];
  return helper();
}
```

Now the demo:

```{r}
tf1 <- via_r_cleanup()
file.exists(tf1)

tf2 <- via_cpp_cleanup()
file.exists(tf2)
```

When called via pure R, cleanup is scheduled in `via_r_cleanup()`'s environment and runs when that function exits, i.e. the tempfile no longer exists.
When routed through C++, cleanup is scheduled in `globalenv()` and the tempfile persists after `via_cpp_cleanup()` returns.

## The `rlang::abort()` example

Another angle: attributing errors to the correct user-facing function via [`rlang::abort()`](https://rlang.r-lib.org/reference/topic-error-call.html).

The helper throws an error, using `caller_env()` to attribute it to its caller:

```{r}
parentframecpp:::helper_that_errors
```

Two wrappers that differ only in *how* they call the helper:

```{r}
via_r_error

via_cpp_error
```

The C++ intermediate:

```cpp
[[cpp11::register]]
void call_error_from_cpp(cpp11::sexp x) {
  cpp11::function helper = cpp11::package("parentframecpp")["helper_that_errors"];
  helper(x);
}
```

Now the demo:

```{r, error = TRUE}
via_r_error()

via_cpp_error()
```

When called via pure R, the error correctly reports `via_r_error()` as the source.
When routed through C++, `caller_env()` resolves to `globalenv()` and the error doesn't mention `via_cpp_error()` at all.
